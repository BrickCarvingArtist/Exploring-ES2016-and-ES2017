## 9. 异步函数 

ECMAScript特性“[Async Functions](https://github.com/tc39/ecmascript-asyncawait)”由Brian Terlson提案出。 

### 9.1 概览 

#### 9.1.1 变量 

下面是现有的异步函数变量。注意所有地方的`async`关键字。 

- 异步函数声明：`async function foo() {}` 
- 异步函数表达式：`const foo = async function () {};` 
- 异步方法定义：`let obj = { async foo() {} }` 
- 异步箭头函数：`const foo = async () => {};` 

#### 9.1.2 异步函数总是返回各种Promise 

达成一个异步函数的Promise： 

```js
async function asyncFunc() {
	return 123;
}

asyncFunc()
.then(x => console.log(x));
	// 123
``` 

抛弃一个异步函数的Promise： 

```js
async function asyncFunc() {
	throw new Error('Problem!');
}

asyncFunc()
.catch(err => console.log(err));
	// Error: Problem!
``` 

#### 9.1.3 通过await处理异步计算的各结果和错误 

操作符`await`（只被允许在异步函数中）等待着它的运算体，一个Promise，将被安放在这里： 

- 如果这个Promise是被达成的，`await`的结果是达成值。 
- 如果这个Promise是被抛弃的，`await`抛出抛弃值。 

处理一个单一异步结果： 

```js
async function asyncFunc() {
	const result = await otherAsyncFunc();
	console.log(result);
}

// 等同于：
function asyncFunc() {
	return otherAsyncFunc()
	.then(result => {
		console.log(result);
	});
}
``` 

连续地处理多个异步结果： 

```js
async function asyncFunc() {
	const result1 = await otherAsyncFunc1();
	console.log(result1);
	const result2 = await otherAsyncFunc2();
	console.log(result2);
}

// 等同于：
function asyncFunc() {
	return otherAsyncFunc1()
	.then(result1 => {
		console.log(result1);
		return otherAsyncFunc2();
	})
	.then(result2 => {
		console.log(result2);
	});
}
``` 

平行地处理多个异步结果： 

```js
async function asyncFunc() {
	const [result1, result2] = await Promise.all([
		otherAsyncFunc1(),
		otherAsyncFunc2(),
	]);
	console.log(result1, result2);
}

// 等同于:
function asyncFunc() {
	return Promise.all([
		otherAsyncFunc1(),
		otherAsyncFunc2(),
	])
	.then([result1, result2] => {
		console.log(result1, result2);
	});
}
```

处理错误： 

```js
async function asyncFunc() {
	try {
		const result = await otherAsyncFunc();
	} catch (err) {
		console.error(err);
	}
}

// 等同于：
function asyncFunc() {
	return otherAsyncFunc()
	.catch(err => {
		console.error(err);
	});
}
``` 

### 9.2 理解异步函数 

在我阐述异步函数前，我需要通过异步式的代码阐述各Promise和各生成器是如何组合成表现各异步操作符。 

对于异步地计算它们一次性的结果的各函数，Promise，ES6中的一部分，变得受欢迎。一个例子是[客户端的`fetch`API](https://fetch.spec.whatwg.org/#concept-request)，就是相比XMLHttpRequest来取回各文件的外另一种选择。像下面这样去使用它： 

```js
function fetchJson(url) {
	return fetch(url)
	.then(request => request.text())
	.then(text => {
		return JSON.parse(text);
	})
	.catch(error => {
		console.log(`ERROR: ${error.stack}`);
	});
}
fetchJson('http://example.com/some_file.json')
.then(obj => console.log(obj));
``` 

#### 9.2.1 通过生成器书写异步的代码 

`co`是一个用各Promise和生成器能使代码风格看起来更异步的库，和前一个例子一样风格的运作： 

```js
const fetchJson = co.wrap(function* (url) {
	try {
		let request = yield fetch(url);
		let text = yield request.text();
		return JSON.parse(text);
	}
	catch (error) {
		console.log(`ERROR: ${error.stack}`);
	}
});
``` 

每当回调函数（一个生成器函数！）生产一个Promise至co，回调函数悬停了。一旦Promise被安放，co重新开始回调函数：如果Promise被达成，`yield`返回实现值，当它被抛弃，`yield`抛出一个抛弃错误。另外的，co使来自回调函数（类似`then()`怎么做的）的结果promise化。 

#### 9.2.2 通过异步函数书写代码 

在co做得事情中异步函数是基本专用语法： 

```js
async function fetchJson(url) {
	try {
		let request = await fetch(url);
		let text = await request.text();
		return JSON.parse(text);
	}
	catch (error) {
		console.log(`ERROR: ${error.stack}`);
	}
}
``` 

内部地，异步函数运作更像生成器。 

#### 9.2.3 异步函数被同步地开始，同步地安放 

这是异步函数被执行的方式： 

1. 异步函数的结果总是一个Promise`p`。那个Promise当开始异步函数执行时被创建。 
2. 函数体被执行。执行过程通过`return`或`throw`永远地结束。或它通过await暂时地结束；在某种情况下执行过程通常将会稍后继续。 
3. Promise`p`被返回。 

当执行异步函数的函数体时，`return x`以`x`处理Promsie`p`，同时也可能有`throw err`带着`err`抛弃`p`。一个有关安置的消息异步地发生。换句话说：`then()`的回调函数和`catch()`都总是在当前代码完成后被执行。 

跟随的代码证明它是如何运作的： 

```js
async function asyncFunc() {
	console.log('asyncFunc()'); //（A）
	return 'abc';
}
asyncFunc().
then(x => console.log(`Resolved: ${x}`)); //（B）
console.log('main'); //（C）

// 输出：
// asyncFunc()
// main
// Resolved: abc
``` 
你可以依从跟随的步骤： 

行（A）：异步函数被同步地开始。异步函数的Promise被由`return`处理。 
行（C）：执行继续。 
行（B）：Promise解决方案的通知异步地发出。 

#### 9.2.4 返回的Promise是不被包裹的 

处理一个Promise是一个标准操作。`return`使用它来处理一个异步函数的Promise`p`。那意味着： 

- 返回一个非Promise的值以那个值达成`p`。 
- 返回一个Promsie意味着`p`反射那个Promise的状态。 

因此，你能返回一个Promise并且那个Promise将不需要被一个Promise包裹： 

```js
async function asyncFunc() {
	return Promise.resolve(123);
}
asyncFunc()
.then(x => console.log(x)) // 123
``` 

有趣的是，返回一个抛弃的`Promise`带领着异步函数的结果将被抛弃（通常地，你需要对它使用`throw`）： 

```js
async function asyncFunc() {
	return Promise.reject(new Error('Problem!'));
}
asyncFunc()
.catch(err => console.error(err)); // Error: Problem!
``` 

这是与Promise处理方式运作方式一致的。它能使你到达另一个异步计算的达成结果和抛弃结果，不用`await`： 

```js
async function asyncFunc() {
	return anotherAsyncFunc();
}
``` 

前面的代码大致得类似于——而相比更有效——下面的代码（拆掉`anotherAsyncFunc`的Promise包裹）只是为了再包裹它一遍： 

```js
async function asyncFunc() {
	return await anotherAsyncFunc();
}
``` 

### 9.3 使用await的小窍门 

#### 9.3.1 别忘了await 

在异步函数中一个要犯的很容易的错误是当做一个异步函数调用时忘记`await`： 

```js
async function asyncFunc() {
	const value = otherAsyncFunc(); // 缺失`await`！
	···
}
``` 

在这个例子中，值设成了一个Promise，那常不是在异步函数中你想要的。 

如果一个异步函数没有返回任何东西，`await`甚至也能理解。然后它的Promise被简单地用作一个用来告诉调用者它是结束了的的符号。例如： 

```js
async function foo() {
	await step1(); //（A）
	···
}
``` 

行（A）中的`await`确保`step1()`在`foo()`的提示信息被执行前是完全完成的。 

#### 9.3.2 当你“触发并遗忘”时你不需要await 

有时，你只是想触发一个异步计算并且对它是否已经完结不感兴趣。接下来的代码就是一个例子： 

```js
async function asyncFunc() {
	const writer = openFile('someFile.txt');
	writer.write('hello'); // 不用等待
	writer.write('world'); // 不用等待
	await writer.close(); // 等待文件关闭
}
``` 

在这里，我们不在意各自的写入什么时候完成的，它们只需要在一个正确的顺序中（API需要保证，那是在异步函数的执行模型中被鼓励的——正如我们所见）。 

在`asyncFunc()`中最后一行的`await`确保函数只在文件被成功关闭后被达成。 

考虑到返回的各Promise是未被包裹的，你也可以`return`而不是`await writer.close()`： 

```js
async function asyncFunc() {
	const writer = openFile('someFile.txt');
	writer.write('hello');
	writer.write('world');
	return writer.close();
}
``` 

两个版本都有利有弊，`await`版本大概稍微容易理解一点。 

#### 9.3.3 await是连续的，Promise.all()是平行的 

下面的代码执行两个异步函数调用，`asyncFunc1()`和`asyncFunc2()`。 

```js
async function foo() {
	const result1 = await asyncFunc1();
	const result2 = await asyncFunc2();
}
``` 

无论如何，这两个函数的调用是被连续地被调用的。平行执行它们将加速这件事情。你可以用`Promise.all()`去做这件事： 

```js
async function foo() {
	const [result1, result2] = await Promise.all([
		asyncFunc1(),
		asyncFunc2(),
	]);
}
``` 

取代等待着两个Promise，我们现在用一个有两个元素的数组等待着一个Promise。 

### 9.4 Async functions and callbacks

One limitation of async functions is that await only affects the directly surrounding async function. Therefore, an async function can’t await in a callback (however, callbacks can be async functions themselves, as we’ll see later on). That makes callback-based utility functions and methods tricky to use. Examples include the Array methods map() and forEach().

#### 9.4.1 Array.prototype.map()

Let’s start with the Array method map(). In the following code, we want to download the files pointed to by an Array of URLs and return them in an Array.

```js
async function downloadContent(urls) {
	return urls.map(url => {
		// Wrong syntax!
		const content = await httpGet(url);
		return content;
	});
}
```

This does not work, because await is syntactically illegal inside normal arrow functions. How about using an async arrow function, then?

```js
async function downloadContent(urls) {
	return urls.map(async (url) => {
		const content = await httpGet(url);
		return content;
	});
}
```

There are two issues with this code:

The result is now an Array of Promises, not an Array of strings.
The work performed by the callbacks isn’t finished once map() is finished, because await only pauses the surrounding arrow function and httpGet() is resolved asynchronously. That means you can’t use await to wait until downloadContent() is finished.
We can fix both issues via Promise.all(), which converts an Array of Promises to a Promise for an Array (with the values fulfilled by the Promises):

```js
async function downloadContent(urls) {
	const promiseArray = urls.map(async (url) => {
		const content = await httpGet(url);
		return content;
	});
	return await Promise.all(promiseArray);
}
```

The callback for map() doesn’t do much with the result of httpGet(), it only forwards it. Therefore, we don’t need an async arrow function here, a normal arrow function will do:

```js
async function downloadContent(urls) {
	const promiseArray = urls.map(
		url => httpGet(url));
	return await Promise.all(promiseArray);
}
```

There is one small improvement that we still can make: This async function is slightly inefficient – it first unwraps the result of Promise.all() via await, before wrapping it again via return. Given that return doesn’t wrap Promises, we can return the result of Promise.all() directly:

```js
async function downloadContent(urls) {
	const promiseArray = urls.map(
		url => httpGet(url));
	return Promise.all(promiseArray);
}
```

#### 9.4.2 Array.prototype.forEach()

Let’s use the Array method forEach() to log the contents of several files pointed to via URLs:

```js
async function logContent(urls) {
	urls.forEach(url => {
		// Wrong syntax
		const content = await httpGet(url);
		console.log(content);
	});
}
```

Again, this code will produce a syntax error, because you can’t use await inside normal arrow functions.

Let’s use an async arrow function:

```js
async function logContent(urls) {
	urls.forEach(async url => {
		const content = await httpGet(url);
		console.log(content);
	});
	// Not finished here
}
```

This does work, but there is one caveat: the Promise returned by httpGet() is resolved asynchronously, which means that the callbacks are not finished when forEach() returns. As a consequence, you can’t await the end of logContent().

If that’s not what you want, you can convert forEach() into a for-of loop:

```js
async function logContent(urls) {
	for (const url of urls) {
		const content = await httpGet(url);
		console.log(content);
	}
}
```

Now everything is finished after the for-of loop. However, the processing steps happen sequentially: httpGet() is only called a second time after the first call is finished. If you want the processing steps to happen in parallel, you must use Promise.all():

```js
async function logContent(urls) {
	await Promise.all(urls.map(
		async url => {
			const content = await httpGet(url);
			console.log(content);            
		}));
}
```

map() is used to create an Array of Promises. We are not interested in the results they fulfill, we only await until all of them are fulfilled. That means that we are completely done at the end of this async function. We could just as well return Promise.all(), but then the result of the function would be an Array whose elements are all undefined.

### 9.5 Tips for using async functions

#### 9.5.1 Know your Promises

The foundation of async functions is Promises. That’s why understanding the latter is crucial for understanding the former. Especially when connecting old code that isn’t based on Promises with async functions, you often have no choice but to use Promises directly.

For example, this is a “promisified” version of XMLHttpRequest:

```js
function httpGet(url, responseType="") {
	return new Promise(
		function (resolve, reject) {
			const request = new XMLHttpRequest();
			request.onload = function () {
				if (this.status === 200) {
					// Success
					resolve(this.response);
				} else {
					// Something went wrong (404 etc.)
					reject(new Error(this.statusText));
				}
			};
			request.onerror = function () {
				reject(new Error(
					'XMLHttpRequest Error: '+this.statusText));
			};
			request.open('GET', url);
			xhr.responseType = responseType;
			request.send();
		});
}
```

The API of XMLHttpRequest is based on callbacks. Promisifying it via an async function would mean that you’d have to fulfill or reject the Promise returned by the function from within callbacks. That’s impossible, because you can only do so via return and throw. And you can’t return the result of a function from within a callback. throw has similar constraints.

Therefore, the common coding style for async functions will be:

Use Promises directly to build asynchronous primitives.
Use those primitives via async functions.
Further reading: chapter “Promises for asynchronous programming” in “Exploring ES6”.

#### 9.5.2 Immediately Invoked Async Function Expressions

Sometimes, it’d be nice if you could use await at the top level of a module or script. Alas, it’s only available inside async functions. You therefore have several options. You can either create an async function main() and call it immediately afterwards:

```js
async function main() {
	console.log(await asyncFunction());
}
main();
```

Or you can use an Immediately Invoked Async Function Expression:

```js
(async function () {
	console.log(await asyncFunction());
})();
```

Another option is an Immediately Invoked Async Arrow Function:

```js
(async () => {
	console.log(await asyncFunction());
})();
```

#### 9.5.3 Unit testing with async functions

The following code uses the test-framework mocha to unit-test the asynchronous functions asyncFunc1() and asyncFunc2():

```js
import assert from 'assert';

// Bug: the following test always succeeds
test('Testing async code', function () {
	asyncFunc1() // (A)
	.then(result1 => {
		assert.strictEqual(result1, 'a'); // (B)
		return asyncFunc2();
	})
	.then(result2 => {
		assert.strictEqual(result2, 'b'); // (C)
	});
});
```

However, this test always succeeds, because mocha doesn’t wait until the assertions in line (B) and line (C) are executed.

You can fix this by returning the result of the Promise chain, because mocha recognizes if a test returns a Promise and then waits until that Promise is settled (unless there is a timeout).

return asyncFunc1() // (A)
Conveniently, async functions always return Promises, which makes them perfect for this kind of unit test:

```js
import assert from 'assert';
test('Testing async code', async function () {
	const result1 = await asyncFunc1();
	assert.strictEqual(result1, 'a');
	const result2 = await asyncFunc2();
	assert.strictEqual(result2, 'b');
});
```

There are thus two advantages to using async functions for asynchronous unit tests in mocha: the code is more concise and returning Promises is taken care of, too.

#### 9.5.4 Don’t worry about unhandled rejections

JavaScript engines are becoming increasingly good at warning about rejections that are not handled. For example, the following code would often fail silently in the past, but most modern JavaScript engines now report an unhandled rejection:

```js
async function foo() {
	throw new Error('Problem!');
}
foo();
```

### 9.6 Further reading

Async Functions (proposal by Brian Terlson)
Simplifying asynchronous computations via generators (section in “Exploring ES6”)

---

首页：[探索ES 2016 和 ES 2017](https://ecmascript-china.github.io/Exploring-ES2016-and-ES2017)

上一章：[在函数参数或者调用中的逗号后缀](https://ecmascript-china.github.io/Exploring-ES2016-and-ES2017/8.在函数参数或者调用中的逗号后缀)
